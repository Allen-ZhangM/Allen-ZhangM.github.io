<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Allen Zhang</title>
    <description>新学期，新气象；百尺竿头，更进一步……</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 05 Nov 2018 20:12:02 +0800</pubDate>
    <lastBuildDate>Mon, 05 Nov 2018 20:12:02 +0800</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>Go语言学习笔记（九）并发</title>
        <description>&lt;h1 id=&quot;并发性concurrency&quot;&gt;并发性Concurrency&lt;/h1&gt;

&lt;p&gt;Go是并发语言，而不是并行语言。在讨论如何在Go中进行并发处理之前，我们首先必须了解什么是并发，以及它与并行性有什么不同。(Go is a concurrent language and not a parallel one. )&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;并发性Concurrency是同时处理许多事情的能力。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;举个例子，假设一个人在晨跑。在晨跑时，他的鞋带松了。现在这个人停止跑步，系鞋带，然后又开始跑步。这是一个典型的并发性示例。这个人能够同时处理跑步和系鞋带，这是一个人能够同时处理很多事情。&lt;/p&gt;

&lt;p&gt;什么是并行性parallelism，它与并发concurrency有什么不同? 并行就是同时做很多事情。这听起来可能与并发类似，但实际上是不同的。&lt;/p&gt;

&lt;p&gt;让我们用同样的慢跑例子更好地理解它。在这种情况下，我们假设这个人正在慢跑，并且使用它的手机听音乐。在这种情况下，一个人一边慢跑一边听音乐，那就是他同时在做很多事情。这就是所谓的并行性(parallelism)。&lt;/p&gt;

&lt;p&gt;并发性和并行性——一种技术上的观点。 设我们正在编写一个web浏览器。web浏览器有各种组件。其中两个是web页面呈现区域和下载文件从internet下载的下载器。假设我们以这样的方式构建了浏览器的代码，这样每个组件都可以独立地执行(这是在Java和Go中使用线程来完成的，我们可以在稍后使用Goroutines来实现这一点)。当这个浏览器运行在单个核处理器中时，处理器将在浏览器的两个组件之间进行上下文切换。它可能会下载一个文件一段时间，然后它可能会切换到呈现用户请求的网页的html。这就是所谓的并发性。并发进程从不同的时间点开始，它们的执行周期重叠。在这种情况下，下载和呈现从不同的时间点开始，它们的执行重叠。假设同一浏览器运行在多核处理器上。在这种情况下，文件下载组件和HTML呈现组件可能同时在不同的内核中运行。这就是所谓的并行性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://om1c35wrq.bkt.clouddn.com/004_concurrency-parallelism-copy.png&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; title=&quot;点击并拖拽以移动&quot; /&gt;​&lt;/p&gt;

&lt;p&gt;并行性Parallelism不会总是导致更快的执行时间。这是因为并行运行的组件可能需要相互通信。例如，在我们的浏览器中，当文件下载完成时，应该将其传递给用户，比如使用弹出窗口。这种通信发生在负责下载的组件和负责呈现用户界面的组件之间。这种通信开销在并发concurrent 系统中很低。当组件在多个内核中并行concurrent 运行时，这种通信开销很高。因此，并行程序并不总是导致更快的执行时间!&lt;/p&gt;

&lt;h2 id=&quot;goroutines&quot;&gt;Goroutines&lt;/h2&gt;

&lt;p&gt;go中使用Goroutines来实现并发concurrently。Goroutines是与其他函数或方法同时运行的函数或方法。Goroutines可以被认为是轻量级的线程。与线程相比，创建Goroutine的成本很小。因此，Go应用程序可以并发运行数千个Goroutines。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Goroutines在线程上的优势。&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;与线程相比，Goroutines非常便宜。它们只是堆栈大小的几个kb，堆栈可以根据应用程序的需要增长和收缩，而在线程的情况下，堆栈大小必须指定并且是固定的&lt;/li&gt;
    &lt;li&gt;Goroutines被多路复用到较少的OS线程。在一个程序中可能只有一个线程与数千个Goroutines。如果线程中的任何Goroutine都表示等待用户输入，则会创建另一个OS线程，剩下的Goroutines被转移到新的OS线程。所有这些都由运行时进行处理，我们作为程序员从这些复杂的细节中抽象出来，并得到了一个与并发工作相关的干净的API。&lt;/li&gt;
    &lt;li&gt;当使用Goroutines访问共享内存时，通过设计的通道可以防止竞态条件发生。通道可以被认为是Goroutines通信的管道。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;如何使用goroutines&quot;&gt;如何使用Goroutines&lt;/h3&gt;

&lt;p&gt;在函数或方法调用前面加上关键字go，您将会同时运行一个新的Goroutine。&lt;/p&gt;

&lt;p&gt;实例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package main

import (
    &quot;fmt&quot;
)

func hello() {
    fmt.Println(&quot;Hello world goroutine&quot;)
}
func main() {
    go hello()
    fmt.Println(&quot;main function&quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：输出“main function”。&lt;/p&gt;

&lt;p&gt;我们开始的Goroutine怎么样了?我们需要了解Goroutine的规则&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当新的Goroutine开始时，Goroutine调用立即返回。与函数不同，go不等待Goroutine执行结束。当Goroutine调用，并且Goroutine的任何返回值被忽略之后，go立即执行到下一行代码。&lt;/li&gt;
  &lt;li&gt;main的Goroutine应该为其他的Goroutines执行。如果main的Goroutine终止了，程序将被终止，而其他Goroutine将不会运行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;修改以上代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func hello() {
    fmt.Println(&quot;Hello world goroutine&quot;)
}
func main() {
    go hello()
    time.Sleep(1 * time.Second)
    fmt.Println(&quot;main function&quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的程序中，我们已经调用了时间包的Sleep方法，它会在执行过程中睡觉。在这种情况下，main的goroutine被用来睡觉1秒。现在调用go hello()有足够的时间在main Goroutine终止之前执行。这个程序首先打印Hello world goroutine，等待1秒，然后打印main函数。&lt;/p&gt;

&lt;h3 id=&quot;启动多个goroutines&quot;&gt;启动多个Goroutines&lt;/h3&gt;

&lt;p&gt;示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func numbers() {
    for i := 1; i &amp;lt;= 5; i++ {
        time.Sleep(250 * time.Millisecond)
        fmt.Printf(&quot;%d &quot;, i)
    }
}
func alphabets() {
    for i := 'a'; i &amp;lt;= 'e'; i++ {
        time.Sleep(400 * time.Millisecond)
        fmt.Printf(&quot;%c &quot;, i)
    }
}
func main() {
    go numbers()
    go alphabets()
    time.Sleep(3000 * time.Millisecond)
    fmt.Println(&quot;main terminated&quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 a 2 3 b 4 c 5 d e main terminated
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;通道channels&quot;&gt;通道channels&lt;/h2&gt;

&lt;p&gt;通道可以被认为是Goroutines通信的管道。类似于管道中的水从一端到另一端的流动，数据可以从一端发送到另一端，通过通道接收。&lt;/p&gt;

&lt;h3 id=&quot;声明通道&quot;&gt;声明通道&lt;/h3&gt;

&lt;p&gt;每个通道都有与其相关的类型。该类型是通道允许传输的数据类型。(通道的零值为nil。nil通道没有任何用处，因此通道必须使用类似于地图和切片的方法来定义。)&lt;/p&gt;

&lt;p&gt;示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package main

import &quot;fmt&quot;

func main() {
    var a chan int
    if a == nil {
        fmt.Println(&quot;channel a is nil, going to define it&quot;)
        a = make(chan int)
        fmt.Printf(&quot;Type of a is %T&quot;, a)
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;channel a is nil, going to define it
Type of a is chan int

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也可以简短的声明：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;a := make(chan int)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;发送和接收&quot;&gt;发送和接收&lt;/h3&gt;

&lt;p&gt;发送和接收的语法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;data := &amp;lt;- a // read from channel a
a &amp;lt;- data // write to channel a

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在通道上箭头的方向指定数据是发送还是接收。&lt;/p&gt;

&lt;h3 id=&quot;发送和接收默认是阻塞的&quot;&gt;发送和接收默认是阻塞的&lt;/h3&gt;

&lt;p&gt;一个通道发送和接收数据，默认是阻塞的。当一个数据被发送到通道时，在发送语句中被阻塞，直到另一个Goroutine从该通道读取数据。类似地，当从通道读取数据时，读取被阻塞，直到一个Goroutine将数据写入该通道。&lt;/p&gt;

&lt;p&gt;这些通道的特性是帮助Goroutines有效地进行通信，而无需像使用其他编程语言中非常常见的显式锁或条件变量。&lt;/p&gt;

&lt;p&gt;示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package main

import (
    &quot;fmt&quot;
)

func hello(done chan bool) {
    fmt.Println(&quot;Hello world goroutine&quot;)
    done &amp;lt;- true
}
func main() {
    done := make(chan bool)
    go hello(done)
    &amp;lt;-done // 接收数据，阻塞式
    fmt.Println(&quot;main function&quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hello world goroutine
main function
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面的程序中，我们在第一行中创建了一个done bool通道。把它作为参数传递给hello Goroutine。第14行我们正在接收已完成频道的数据。这一行代码是阻塞的，这意味着在某些Goroutine将数据写入到已完成的通道之前，程序将不会执行到下一行代码。因此，这就消除了对时间的需求。睡眠在原来的程序中，以防止主要的Goroutine退出。&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B9%9D-%E5%B9%B6%E5%8F%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B9%9D-%E5%B9%B6%E5%8F%91/</guid>
        
        
      </item>
    
      <item>
        <title>Go语言学习笔记（八） 面向对象</title>
        <description>&lt;p&gt;go并不是一个纯面向对象的编程语言。在go中的面向对象，结构体替换了类。&lt;br /&gt;
Go并没有提供类class，但是它提供了结构体struct，方法method，可以在结构体上添加。提供了捆绑数据和方法的行为，这些数据和方法与类类似。&lt;/p&gt;

&lt;h2 id=&quot;定义结构体和方法&quot;&gt;定义结构体和方法&lt;/h2&gt;

&lt;p&gt;创建一个外部可访问的Employee结构体，并为这个结构体定义一个方法LeavesRemaining()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package employee

import (
    &quot;fmt&quot;
)

type Employee struct {
    FirstName   string
    LastName    string
    TotalLeaves int
    LeavesTaken int
}

func (e Employee) LeavesRemaining() {
    fmt.Printf(&quot;%s %s has %d leaves remaining&quot;, e.FirstName, e.LastName, (e.TotalLeaves - e.LeavesTaken))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在另一个包下创建main.go&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package main

import &quot;oop/employee&quot;

func main() {
    e := employee.Employee {
        FirstName: &quot;Sam&quot;,
        LastName: &quot;Adolf&quot;,
        TotalLeaves: 30,
        LeavesTaken: 20,
    }
    e.LeavesRemaining()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果无误&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;Sam Adolf has 10 leaves remaining
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;new函数替代了构造函数&quot;&gt;New()函数替代了构造函数&lt;/h2&gt;

&lt;p&gt;我们上面写的程序看起来不错，但是里面有一个微妙的问题。让我们看看当我们用0值定义employee struct时会发生什么。更改main的内容。转到下面的代码，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package main

import &quot;oop/employee&quot;

func main() {
    var e employee.Employee
    e.LeavesRemaining()
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;has 0 leaves remaining

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过运行结果可以知道，使用Employee的零值创建的变量是不可用的。它没有有效的名、姓，也没有有效的保留细节。在其他的OOP语言中，比如java，这个问题可以通过使用构造函数来解决。使用参数化构造函数可以创建一个有效的对象。&lt;/p&gt;

&lt;p&gt;go不支持构造函数。如果某个类型的零值不可用，则程序员的任务是不导出该类型以防止其他包的访问，并提供一个名为NewT(parameters)的函数，该函数初始化类型T和所需的值。在go中，它是一个命名一个函数的约定，它创建了一个T类型的值给NewT(parameters)。这就像一个构造函数。如果包只定义了一个类型，那么它的一个约定就是将这个函数命名为New(parameters)而不是NewT(parameters)。&lt;/p&gt;

&lt;p&gt;更改employee.go的代码：&lt;/p&gt;

&lt;p&gt;首先修改employee结构体为非导出，并创建一个函数New()，它将创建一个新Employee。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package employee

import (
    &quot;fmt&quot;
)

type employee struct {
    firstName   string
    lastName    string
    totalLeaves int
    leavesTaken int
}

func New(firstName string, lastName string, totalLeave int, leavesTaken int) employee {
    e := employee {firstName, lastName, totalLeave, leavesTaken}
    return e
}

func (e employee) LeavesRemaining() {
    fmt.Printf(&quot;%s %s has %d leaves remaining&quot;, e.firstName, e.lastName, (e.totalLeaves - e.leavesTaken))
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在这里做了一些重要的改变。我们已经将Employee struct的起始字母e设置为小写，即我们已经将类型Employee struct更改为type Employee struct。通过这样做，我们成功地导出了employee结构并阻止了其他包的访问。将未导出的结构的所有字段都导出为未导出的方法是很好的做法，除非有特定的需要导出它们。由于我们不需要在包之外的任何地方使用employee struct的字段，所以我们也没有导出所有字段。&lt;/p&gt;

&lt;p&gt;由于employee是未导出的，所以不可能从其他包中创建类型employee的值。因此，我们提供了一个输出的新函数。将所需的参数作为输入并返回新创建的employee。&lt;/p&gt;

&lt;p&gt;这个程序还需要做一些修改，让它能够工作，但是让我们运行这个程序来了解到目前为止变化的效果。如果这个程序运行，它将会失败，有以下编译错误，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;go/src/constructor/main.go:6: undefined: employee.Employee

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这是因为我们有未导出的Employee，因此编译器抛出错误，该类型在main中没有定义。完美的。正是我们想要的。现在没有其他的包能够创建一个零值的员工。我们成功地防止了一个无法使用的员工结构价值被创建。现在创建员工的唯一方法是使用新功能。&lt;/p&gt;

&lt;p&gt;修改main.go代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package main

import &quot;oop/employee&quot;

func main() {
    e := employee.New(&quot;Sam&quot;, &quot;Adolf&quot;, 30, 20)
    e.LeavesRemaining()
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sam Adolf has 10 leaves remaining

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因此，我们可以明白，虽然Go不支持类，但是结构体可以有效地使用，在使用构造函数的位置，使用New(parameters)的方法即可。&lt;/p&gt;

&lt;h2 id=&quot;组成composition-替代了继承inheritance&quot;&gt;组成(Composition )替代了继承(Inheritance)&lt;/h2&gt;

&lt;p&gt;Go不支持继承，但它支持组合。组合的一般定义是“放在一起”。构图的一个例子就是汽车。汽车是由轮子、发动机和其他各种部件组成的。&lt;/p&gt;

&lt;p&gt;博客文章就是一个完美的组合例子。每个博客都有标题、内容和作者信息。这可以用组合完美地表示出来。&lt;/p&gt;

&lt;h3 id=&quot;通过嵌入结构体实现组成&quot;&gt;通过嵌入结构体实现组成&lt;/h3&gt;

&lt;p&gt;可以通过将一个struct类型嵌入到另一个结构中实现。&lt;/p&gt;

&lt;p&gt;示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package main

import (
    &quot;fmt&quot;
)

/*
我们创建了一个author struct，它包含字段名、lastName和bio。我们还添加了一个方法fullName()，将作者作为接收者类型，这将返回作者的全名。
*/
type author struct {
    firstName string
    lastName  string
    bio       string
}

func (a author) fullName() string {
    return fmt.Sprintf(&quot;%s %s&quot;, a.firstName, a.lastName)
}
/*
post struct有字段标题、内容。它还有一个嵌入式匿名字段作者。这个字段表示post struct是由author组成的。现在post struct可以访问作者结构的所有字段和方法。我们还在post struct中添加了details()方法，它打印出作者的标题、内容、全名和bio。
*/
type post struct {
    title     string
    content   string
    author
}

func (p post) details() {
    fmt.Println(&quot;Title: &quot;, p.title)
    fmt.Println(&quot;Content: &quot;, p.content)
    fmt.Println(&quot;Author: &quot;, p.author.fullName())
    fmt.Println(&quot;Bio: &quot;, p.author.bio)
}

func main() {
    author1 := author{
        &quot;Naveen&quot;,
        &quot;Ramanathan&quot;,
        &quot;Golang Enthusiast&quot;,
    }
    post1 := post{
        &quot;Inheritance in Go&quot;,
        &quot;Go supports composition instead of inheritance&quot;,
        author1,
    }
    post1.details()
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Title:  Inheritance in Go
Content:  Go supports composition instead of inheritance
Author:  Naveen Ramanathan
Bio:  Golang Enthusiast

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;嵌入结构体的切片&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在以上程序的main函数下增加以下代码，并运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;type website struct {
        []post
}
func (w website) contents() {
    fmt.Println(&quot;Contents of Website\n&quot;)
    for _, v := range w.posts {
        v.details()
        fmt.Println()
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行报错：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;main.go:31:9: syntax error: unexpected [, expecting field name or embedded type

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个错误指向structs []post的嵌入部分。原因是不可能匿名嵌入一片。需要一个字段名。我们来修正这个错误，让编译器通过。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;type website struct {
        posts []post
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在让我们修改的main函数,为我们的新的website创建几个posts。修改完完整代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package main

import (
    &quot;fmt&quot;
)

type author struct {
    firstName string
    lastName  string
    bio       string
}

func (a author) fullName() string {
    return fmt.Sprintf(&quot;%s %s&quot;, a.firstName, a.lastName)
}

type post struct {
    title   string
    content string
    author
}
func (p post) details() {
    fmt.Println(&quot;Title: &quot;, p.title)
    fmt.Println(&quot;Content: &quot;, p.content)
    fmt.Println(&quot;Author: &quot;, p.fullName())
    fmt.Println(&quot;Bio: &quot;, p.bio)
}

type website struct {
    posts []post
}
func (w website) contents() {
    fmt.Println(&quot;Contents of Website\n&quot;)
    for _, v := range w.posts {
        v.details()
        fmt.Println()
    }
}
func main() {
    author1 := author{
        &quot;Naveen&quot;,
        &quot;Ramanathan&quot;,
        &quot;Golang Enthusiast&quot;,
    }
    post1 := post{
        &quot;Inheritance in Go&quot;,
        &quot;Go supports composition instead of inheritance&quot;,
        author1,
    }
    post2 := post{
        &quot;Struct instead of Classes in Go&quot;,
        &quot;Go does not support classes but methods can be added to structs&quot;,
        author1,
    }
    post3 := post{
        &quot;Concurrency&quot;,
        &quot;Go is a concurrent language and not a parallel one&quot;,
        author1,
    }
    w := website{
        posts: []post{post1, post2, post3},
    }
    w.contents()
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Contents of Website

Title:  Inheritance in Go
Content:  Go supports composition instead of inheritance
Author:  Naveen Ramanathan
Bio:  Golang Enthusiast

Title:  Struct instead of Classes in Go
Content:  Go does not support classes but methods can be added to structs
Author:  Naveen Ramanathan
Bio:  Golang Enthusiast

Title:  Concurrency
Content:  Go is a concurrent language and not a parallel one
Author:  Naveen Ramanathan
Bio:  Golang Enthusiast

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;多态性polymorphism&quot;&gt;多态性(Polymorphism)&lt;/h2&gt;

&lt;p&gt;Go中的多态性是在接口的帮助下实现的。正如我们已经讨论过的，接口可以在Go中隐式地实现。如果类型为接口中声明的所有方法提供了定义，则实现一个接口。让我们看看在接口的帮助下如何实现多态。&lt;/p&gt;

&lt;p&gt;任何定义接口所有方法的类型都被称为隐式地实现该接口。&lt;/p&gt;

&lt;p&gt;类型接口的变量可以保存实现接口的任何值。接口的这个属性用于实现Go中的多态性。&lt;/p&gt;

&lt;p&gt;举个例子，一个虚构的组织有两种项目的收入:固定的账单和时间和材料。组织的净收入是由这些项目的收入之和计算出来的。为了保持本教程的简单，我们假设货币是美元，我们不会处理美分。它将使用整数来表示。&lt;/p&gt;

&lt;p&gt;首先定义一个接口：Income&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;type Income interface {
    calculate() int
    source() string
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，定义两个结构体：FixedBilling和TimeAndMaterial&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;type FixedBilling struct {
    projectName string
    biddedAmount int
}

type TimeAndMaterial struct {
    projectName string
    noOfHours  int
    hourlyRate int
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下一步是定义这些结构体类型的方法，计算并返回实际收入和收入来源。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;func (fb FixedBilling) calculate() int {
    return fb.biddedAmount
}

func (fb FixedBilling) source() string {
    return fb.projectName
}

func (tm TimeAndMaterial) calculate() int {
    return tm.noOfHours * tm.hourlyRate
}

func (tm TimeAndMaterial) source() string {
    return tm.projectName
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们来声明一下计算和打印总收入的calculateNetIncome函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;func calculateNetIncome(ic []Income) {
    var netincome int = 0
    for _, income := range ic {
        fmt.Printf(&quot;Income From %s = $%d\n&quot;, income.source(), income.calculate())
        netincome += income.calculate()
    }
    fmt.Printf(&quot;Net income of organisation = $%d&quot;, netincome)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的calculateNetIncome函数接受一部分Income接口作为参数。它通过遍历切片和调用calculate()方法来计算总收入。它还通过调用source()方法来显示收入来源。根据收入接口的具体类型，将调用不同的calculate()和source()方法。因此，我们在calculateNetIncome函数中实现了多态。&lt;/p&gt;

&lt;p&gt;在未来，如果组织增加了一种新的收入来源，这个函数仍然可以正确地计算总收入，而没有一行代码更改。&lt;/p&gt;

&lt;p&gt;最后我们写以下主函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;func main() {
    project1 := FixedBilling{projectName: &quot;Project 1&quot;, biddedAmount: 5000}
    project2 := FixedBilling{projectName: &quot;Project 2&quot;, biddedAmount: 10000}
    project3 := TimeAndMaterial{projectName: &quot;Project 3&quot;, noOfHours: 160, hourlyRate: 25}
    incomeStreams := []Income{project1, project2, project3}
    calculateNetIncome(incomeStreams)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Income From Project 1 = $5000
Income From Project 2 = $10000
Income From Project 3 = $4000
Net income of organisation = $19000

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;假设该组织通过广告找到了新的收入来源。让我们看看如何简单地添加新的收入方式和计算总收入，而不用对calculateNetIncome函数做任何更改。由于多态性，这样是可行的。&lt;/p&gt;

&lt;p&gt;首先让我们定义Advertisement类型和calculate()和source()方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;type Advertisement struct {
    adName     string
    CPC        int
    noOfClicks int
}

func (a Advertisement) calculate() int {
    return a.CPC * a.noOfClicks
}

func (a Advertisement) source() string {
    return a.adName
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;广告类型有三个字段adName, CPC(cost per click)和noof点击数(cost per click)。广告的总收入是CPC和noOfClicks的产品。&lt;/p&gt;

&lt;p&gt;修改主函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;func main() {
    project1 := FixedBilling{projectName: &quot;Project 1&quot;, biddedAmount: 5000}
    project2 := FixedBilling{projectName: &quot;Project 2&quot;, biddedAmount: 10000}
    project3 := TimeAndMaterial{projectName: &quot;Project 3&quot;, noOfHours: 160, hourlyRate: 25}
    bannerAd := Advertisement{adName: &quot;Banner Ad&quot;, CPC: 2, noOfClicks: 500}
    popupAd := Advertisement{adName: &quot;Popup Ad&quot;, CPC: 5, noOfClicks: 750}
    incomeStreams := []Income{project1, project2, project3, bannerAd, popupAd}
    calculateNetIncome(incomeStreams)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Income From Project 1 = $5000
Income From Project 2 = $10000
Income From Project 3 = $4000
Income From Banner Ad = $1000
Income From Popup Ad = $3750
Net income of organisation = $23750

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;没有对calculateNetIncome函数做任何更改，尽管添加了新的收入方式。它只是因为多态性而起作用。由于新的Advertisement类型也实现了Income接口，我们可以将它添加到incomeStreams切片中。calculateNetIncome函数也在没有任何更改的情况下工作，因为它可以调用Advertisement类型的calculate()和source()方法。&lt;/p&gt;
</description>
        <pubDate>Wed, 11 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AB-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AB-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
        
        
      </item>
    
      <item>
        <title>Go语言学习笔记（七） 系统类型</title>
        <description>&lt;h2 id=&quot;系统类型&quot;&gt;系统类型&lt;/h2&gt;

&lt;p&gt;对于面向对象编程的支持Go 语言设计得非常简洁而优雅。简洁之处在于，Go语言并没有沿袭传统面向对象编程中的诸多概念，比如继承、虚函数、构造函数和析构函数、隐藏的this指针等。优雅之处在于，Go语言对面向对象编程的支持是语言类型系统中的天然组成部分。整个类型系统通过接口串联，浑然一体。&lt;/p&gt;

&lt;p&gt;在Java语言中，存在两套完全独立的类型系统：一套是值类型系统，主要是基本类型，如byte、int、boolean、char、double等，这些类型基于值语义；一套是以Object类型为根的对象类型系统，这些类型可以定义成员变量和成员方法，可以有虚函数，基于引用语义，只允许在堆上创建（通过使用关键字new）。&lt;/p&gt;

&lt;p&gt;Java语言中的Any类型就是整个对象类型系统的根——java.lang.Object类型，只有对象类型系统中的实例才可以被Any类型引用。值类型想要被Any类型引用，需要装箱（boxing）过程，比如int类型需要装箱成为Integer类型。另外，只有对象类型系统中的类型才可以实现接口，具体方法是让该类型从要实现的接口继承。相比之下，Go语言中的大多数类型都是值语义，并且都可以包含对应的操作方法。在需要的时候，你可以给任何类型（包括内置类型）“增加”新方法。而在实现某个接口时，无需从该接口继承（事实上，Go语言根本就不支持面向对象思想中的继承语法），只需要实现该接口要求的所有方法即可。任何类型都可以被Any类型引用。Any类型就是空接口，即interface{}。&lt;/p&gt;

&lt;p&gt;你可以给任意类型（包括内置类型，但不包括指针类型）添加相应的方法，它和int没有本质不同，只是它为内置的int类型增加了个新方法Less()。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;type Integer int
func (a Integer) Less(b Integer) bool {
    return a &amp;lt; b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“在Go语言中没有隐藏的this指针”这句话的含义是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法施加的目标（也就是“对象”）显式传递，没有被隐藏起来；&lt;/li&gt;
  &lt;li&gt;方法施加的目标（也就是“对象”）不需要非得是指针，也不用非得叫this。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为Integer类型增加了Add()方法。由于Add()方法需要修改对象的值，所以需要用指针引用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;func (a *Integer) Add(b Integer) {
    *a += b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Integer类型其实就是一个int，但通过为int起一个Integer别名并增加了一系列方法，它就变成了一个全新的类型，但这个新类型又完全拥有int的功能。&lt;/p&gt;

&lt;h2 id=&quot;值语义和引用语义&quot;&gt;值语义和引用语义&lt;/h2&gt;

&lt;p&gt;Go语言中的数组和基本类型没有区别，是很纯粹的值类型，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;var a = [3]int{1, 2, 3}
var b = a
b[1]++
fmt.Println(a, b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该程序的运行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;[1 2 3] [1 3 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这表明b=a赋值语句是数组内容的完整复制。要想表达引用，需要用指针：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;var a = [3]int{1, 2, 3}
var b = &amp;amp;a
b[1]++
fmt.Println(a, *b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该程序的运行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;[1 3 3] [1 3 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这表明b=&amp;amp;a赋值语句是数组内容的引用。变量b的类型不是[3]int，而是*[3]int类型。&lt;/p&gt;

&lt;h2 id=&quot;结构体&quot;&gt;结构体&lt;/h2&gt;

&lt;p&gt;Go语言的结构体（struct）和其他语言的类（class）有同等的地位，但Go语言放弃了包括继承在内的大量面向对象特性，只保留了组合（composition）这个最基础的特性。&lt;/p&gt;

&lt;p&gt;所有的Go语言类型（指针类型除外）都可以有自己的方法。在这个背景下，Go语言的结构体只是很普通的复合类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;type Rect struct {
    x, y float64
    width, height float64
}
func (r *Rect) Area() float64 {
    return r.width * r.height
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;初始化&quot;&gt;初始化&lt;/h2&gt;

&lt;p&gt;创建并初始化Rect类型的对象实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;rect1 := new(Rect)
rect2 := &amp;amp;Rect{}
rect3 := &amp;amp;Rect{0, 0, 100, 200}
rect4 := &amp;amp;Rect{width: 100, height: 200}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Go语言中，未进行显式初始化的变量都会被初始化为该类型的零值，例如bool类型的零值为false，int类型的零值为0，string类型的零值为空字符串。在Go语言中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名，表示“构造函数”：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;func NewRect(x, y, width, height float64) *Rect {
    return &amp;amp;Rect{x, y, width, height}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;匿名组合&quot;&gt;匿名组合&lt;/h2&gt;

&lt;p&gt;Go语言也提供了继承，但是采用了组合的文法，所以我们将其称为匿名组合：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;type Base struct {
    Name string
}
func (base *Base) Foo() { ... }
func (base *Base) Bar() { ... }
type Foo struct {
    Base
    ...
}
func (foo *Foo) Bar() {
    foo.Base.Bar()
    ...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码定义了一个Base类（实现了Foo()和Bar()两个成员方法），然后定义了一个Foo类，该类从Base类“继承”并改写了Bar()方法（该方法实现时先调用了基类的Bar()方法）。在“派生类”Foo没有改写“基类”Base的成员方法时，相应的方法就被“继承”，例如在上面的例子中，调用foo.Foo()和调用foo.Base.Foo()效果一致。&lt;/p&gt;

&lt;h2 id=&quot;可见性&quot;&gt;可见性&lt;/h2&gt;

&lt;p&gt;要使某个符号对其他包（package）可见（即可以访问），需要将该符号定义为以大写字母开头，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;//Rect类型的成员变量就全部被导出了
type Rect struct {
    X, Y float64
    Width, Height float64
}
//Rect的area()方法只能在该类型所在的包内使用
func (r *Rect) area() float64 {
    return r.Width * r.Height
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的一点是，Go语言中符号的可访问性是包一级的而不是类型一级的。在上面的例子中，尽管area()是Rect的内部方法，但同一个包中的其他类型也都可以访问到它。这样的可访问性控制很粗旷，很特别，但是非常实用。&lt;/p&gt;
</description>
        <pubDate>Tue, 10 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%83-%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%83-%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B/</guid>
        
        
      </item>
    
      <item>
        <title>Go语言学习笔记（六） 错误处理</title>
        <description>&lt;h2 id=&quot;error接口&quot;&gt;error接口&lt;/h2&gt;

&lt;p&gt;Go语言引入了一个关于错误处理的标准模式，即error接口，该接口的定义如下：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于大多数函数，如果要返回错误，大致上都可以定义为如下模式，将error作为多种返回&lt;br /&gt;
值中的最后一个，但这并非是强制要求：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// ...&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用时的代码建议按如下方式处理错误情况：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 错误处理&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 使用返回值n&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用自定义的error类型：&lt;/p&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;errors&quot;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// By convention, errors are the last return value and&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// have type `error`, a built-in interface.&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

        &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// `errors.New` constructs a basic `error` value&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// with the given error message.&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;New&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;can't work with 42&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// A nil value in the error position indicates that&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// there was no error.&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// It's possible to use custom types as `error`s by&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// implementing the `Error()` method on them. Here's a&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// variant on the example above that uses a custom type&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// to explicitly represent an argument error.&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argError&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prob&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d - %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

        &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// In this case we use `&amp;amp;argError` syntax to build&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// a new struct, supplying values for the two&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// fields `arg` and `prob`.&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;can't work with it&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// The two loops below test out each of our&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// error-returning functions. Note that the use of an&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// inline error check on the `if` line is a common&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// idiom in Go code.&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;f1 failed:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;f1 worked:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;f2 failed:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;f2 worked:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// If you want to programmatically use the data in&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// a custom error, you'll need to get the error  as an&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// instance of the custom error type via type&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// assertion.&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ae&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ae&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ae&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;执行结果&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worked&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;can&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;work&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worked&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;can&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;work&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;can&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;work&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;defer&quot;&gt;defer&lt;/h2&gt;

&lt;p&gt;一个函数中可以存在多个defer语句，因此需要注意的是，defer语句的调用是遵照先进后出的原则，即最后一个defer语句将最先被执行。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;file&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//file.Close() 被添加到了defer 列表&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 做一些工作&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failureX&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//Close() 现在自动调用&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failureY&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//这里也是&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也可以使用在defer后加一个匿名函数的做法：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 做你复杂的清理工作&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还需要注意的一点是，&lt;strong&gt;defer需要先被加载之后才会生效&lt;/strong&gt;，即如果函数返回前没执行到defer语句则不会触发，参考下面的例子。&lt;/p&gt;

&lt;h2 id=&quot;恐慌panic和恢复recover&quot;&gt;恐慌（Panic）和恢复（Recover）&lt;/h2&gt;

&lt;p&gt;Panic&lt;/p&gt;

&lt;p&gt;是一个内建函数，可以中断原有的控制流程，进入一个令人恐慌的流程中。当函数F 调用panic，函数F 的执行被中断，并且F 中的延迟函数会正常执行，然后F 返回到调用它的地方。在调用的地方， F 的行为就像调用了panic。这一过程继续向上，直到程序崩溃时的所有goroutine 返回。恐慌可以直接调用panic 产生。也可以由运行时错误产生，例如访问越界的数组。&lt;/p&gt;

&lt;p&gt;Recover&lt;br /&gt;
是一个内建的函数，可以让进入令人恐慌的流程中的goroutine 恢复过来。recover 仅在延迟函数中有效。在正常的执行过程中，调用recover 会返回nil 并且没有其他任何效果。如果当前的goroutine 陷入恐慌，调用recover 可以捕获到panic 的输入值，并且恢复正常的执行。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//如果在这个位置添加panic，则不会触发defer&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//panic(&quot;a problem&quot;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//退出之前执行延迟函数&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;recover&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
			&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//输出错误信息a problem&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
			&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;recover a problem&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 发现错误，程序退出&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a problem&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;//下面的代码不会执行到&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;no problem&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sun, 08 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
        
        
      </item>
    
      <item>
        <title>Go语言学习笔记（五） 函数</title>
        <description>&lt;h2 id=&quot;函数定义&quot;&gt;函数定义&lt;/h2&gt;

&lt;p&gt;函数构成代码执行的逻辑结构。在Go语言中，函数的基本组成为：关键字func、函数名、参数列表、返回值、函数体和返回语句。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mytype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;funcname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;func：保留字func 用于定义一个函数&lt;/li&gt;
  &lt;li&gt;(p mytype)：可省略。函数可以定义用于特定的类型，比如这个函数只有mytype类型才可以调用&lt;/li&gt;
  &lt;li&gt;funcname：函数的名字&lt;/li&gt;
  &lt;li&gt;(q int)：int 类型的变量q 作为输入参数。参数用pass-by-value 方式传递，意味着它们会被复制&lt;/li&gt;
  &lt;li&gt;(r,s int)：可省略。变量r和s是这个函数的命名返回值。可以省略返回参数名（int,int）。如果只有一个返回值，可以省略圆括号&lt;/li&gt;
  &lt;li&gt;{return 0,0}：函数体以及返回值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;函数调用&quot;&gt;函数调用&lt;/h2&gt;

&lt;p&gt;只要事先导入了该函数所在的包，就可以直接按照如下所示的方式调用函数：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mymath&quot;&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 假设Add被放在一个叫mymath的包中&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// ...&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mymath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;牢记这样的规则：&lt;strong&gt;小写字母开头的函数只在本包内可见，大写字母开头的函数才能被其他包使用。这个规则也适用于类型和变量的可见性。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;不定参数&quot;&gt;&lt;strong&gt;不定参数&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;不定参数类型：形如…type格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数。它是一个语法糖。从内部实现机理上来说，类型…type本质上是一个数组切片，也就是[]type，这也是为什么参数args可以用for循环来获得每个传入的参数。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myfunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;任意类型的不定参数：可接受任意类型、个数的fmt.Println()方法&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fprintln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不定参数的传递：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myfunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 按原样传递&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myfunc3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 传递片段，实际上任意的int slice都可以传进去&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myfunc3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;多返回值&quot;&gt;多返回值&lt;/h2&gt;

&lt;p&gt;函数或者成员的方法可以有多个返回值，还可以给返回值命名，就像函数的输入参数一样。在函数中执行不带任何参数的return语句时，会返回对应的返回值变量的值。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“&lt;em&gt;”来跳过这个返回值，但是不可以只写某一个返回值，下划线“&lt;/em&gt;”不可省略：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;匿名函数&quot;&gt;匿名函数&lt;/h2&gt;

&lt;p&gt;函数可以像普通变量一样被传递或使用，支持随时在代码里定义匿名函数。&lt;/p&gt;

&lt;p&gt;由一个不带函数名的函数声明和函数体组成：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;直接赋值给一个变量：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;直接执行：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ACK&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reply_chan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;// 花括号后直接跟参数列表表示函数调用&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;闭包&quot;&gt;闭包&lt;/h2&gt;

&lt;p&gt;闭包是可以包含自由（未绑定到特定对象）变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块（由于自由变量包含在代码块中，所以这些自由变量以及它们引用的对象没有被释放）为自由变量提供绑定的计算环境（作用域）。&lt;/p&gt;

&lt;p&gt;闭包的价值在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第一级对象，就是说这些函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Adder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Adder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;输出如下&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;21&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;321&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94-%E5%87%BD%E6%95%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94-%E5%87%BD%E6%95%B0/</guid>
        
        
      </item>
    
      <item>
        <title>Go语言学习笔记（四） 流程控制</title>
        <description>&lt;p&gt;程序设计语言的流程控制语句，用于设定计算执行的次序，建立程序的逻辑结构。可以说，流程控制语句是整个程序的骨架。从根本上讲，流程控制只是为了控制程序语句的执行顺序，一般需要与各种条件配合，因此，在各种流程中，会加入条件判断语句。流程控制语句一般起以下3个作用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;选择，即根据条件跳转到不同的执行序列；&lt;/li&gt;
  &lt;li&gt;循环，即根据条件反复执行某个序列，当然每一次循环执行的输入输出可能会发生变化；&lt;/li&gt;
  &lt;li&gt;跳转，即根据条件返回到某执行序列。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go语言支持如下的几种流程控制语句：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;条件语句，对应的关键字为if、else和else if；&lt;/li&gt;
  &lt;li&gt;选择语句，对应的关键字为switch、case和select（将在介绍channel的时候细说）；&lt;/li&gt;
  &lt;li&gt;循环语句，对应的关键字为for和range；&lt;/li&gt;
  &lt;li&gt;跳转语句，对应的关键字为goto。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在具体的应用场景中，为了满足更丰富的控制需求，Go语言还添加了如下关键字：break、continue和fallthrough。在实际的使用中，需要根据具体的逻辑目标、程序执行的时间和空间限制、代码的可读性、编译器的代码优化设定等多种因素，灵活组合。&lt;/p&gt;

&lt;h2 id=&quot;选择语句&quot;&gt;选择语句&lt;/h2&gt;

&lt;p&gt;根据传入条件的不同，选择语句会执行不同的语句。下面的例子根据传入的整型变量i的不同而打印不同的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;	switch i {
	case 0:
		fmt.Printf(&quot;0&quot;)
	case 1:
		fmt.Printf(&quot;1&quot;)
	case 2:
		fallthrough//不退出switch而继续执行
	case 3:
		fmt.Printf(&quot;3&quot;)
	case 4, 5, 6:
		fmt.Printf(&quot;4, 5, 6&quot;)
	default:
		fmt.Printf(&quot;Default&quot;)
	}
	运行上面的案例，将会得到如下结果：
	i = 0时，输出0；
	i = 1时，输出1；
	i = 2时，输出3；
	i = 3时，输出3；
	i = 4时，输出4, 5, 6；
	i = 5时，输出4, 5, 6；
	i = 6时，输出4, 5, 6；
	i = 其他任意值时，输出Default。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;switch后面的表达式甚至不是必需的，比如下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;	switch {
	case 0 &amp;lt;= Num &amp;amp;&amp;amp; Num &amp;lt;= 3:
		fmt.Printf(&quot;0-3&quot;)
	case 4 &amp;lt;= Num &amp;amp;&amp;amp; Num &amp;lt;= 6:
		fmt.Printf(&quot;4-6&quot;)
	case 7 &amp;lt;= Num &amp;amp;&amp;amp; Num &amp;lt;= 9:
		fmt.Printf(&quot;7-9&quot;)
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用switch结构时，我们需要注意以下几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;左花括号{必须与switch处于同一行；&lt;/li&gt;
  &lt;li&gt;条件表达式不限制为常量或者整数；&lt;/li&gt;
  &lt;li&gt;单个case中，可以出现多个结果选项；&lt;/li&gt;
  &lt;li&gt;与C语言等规则相反，Go语言不需要用break来明确退出一个case；&lt;/li&gt;
  &lt;li&gt;只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case；&lt;/li&gt;
  &lt;li&gt;可以不设定switch之后的条件表达式，在此种情况下，整个switch结构与多个if…else…的逻辑作用等同。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;循环语句&quot;&gt;循环语句&lt;/h2&gt;

&lt;p&gt;与多数语言不同的是，Go语言中的循环语句只支持for关键字，而不支持while和do-while结构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;sum := 0
for i := 0; i &amp;lt; 10; i++ {
    sum += i
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无限循环，替代while&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;	for {
		sum++
		if sum &amp;gt; 100 {
			break
		}
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在条件表达式中也支持多重赋值，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;a := []int{1, 2, 3, 4, 5, 6}
for i, j := 0, len(a) – 1; i &amp;lt; j; i, j = i + 1, j – 1 {
    a[i], a[j] = a[j], a[i]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用循环语句时，需要注意的有以下几点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;左花括号{必须与for处于同一行。&lt;/li&gt;
  &lt;li&gt;Go语言中的for循环与C语言一样，都允许在循环条件中定义和初始化变量，唯一的区别是，Go语言不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量。&lt;/li&gt;
  &lt;li&gt;Go语言的for循环同样支持continue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环，如下例：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;	for j := 0; j &amp;lt; 5; j++ {
		for i := 0; i &amp;lt; 10; i++ {
			if i &amp;gt; 5 {
				break JLoop  //break语句终止的是JLoop标签处的外层循环
			}
			fmt.Println(i)
		}
	}
JLoop:
	// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;跳转语句&quot;&gt;跳转语句&lt;/h2&gt;

&lt;p&gt;goto还是会在一些场合下被证明是最合适的，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;	func myfunc() {
		i := 0
	HERE:
		fmt.Println(i)
		i++
		if i &amp;lt; 10 {
			goto HERE
		}
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 27 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
        
        
      </item>
    
      <item>
        <title>Go语言学习笔记（三） 集合类型</title>
        <description>
&lt;h2 id=&quot;数组&quot;&gt;数组&lt;/h2&gt;

&lt;p&gt;数组中包含的每个数据被称为数组元素（element），一个数组包含的元素个数被称为数组的长度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;[32]byte // 长度为32的数组，每个元素为一个字节
[2*N] struct { x, y int32 } // 复杂类型数组
[1000]*float64 // 指针数组
[3][5]int // 二维数组
[2][2][2]float64 // 等同于[2]([2]([2]float64))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;元素访问&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;	for i := 0; i &amp;lt; len(array); i++ {
		fmt.Println(&quot;Element&quot;, i, &quot;of array is&quot;, array[i])
	}
	for i, v := range array {
		fmt.Println(&quot;Array element[&quot;, i, &quot;]=&quot;, v)
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Go语言中数组是一个值类型（value type）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package main

import &quot;fmt&quot;

func modify(array [10]int) {
	array[0] = 10 // 试图修改数组的第一个元素
	fmt.Println(&quot;In modify(), array values:&quot;, array)
}
func main() {
	array := [10]int{1, 2, 3, 4, 5} // 定义并初始化一个数组，未定义的元素为零值，即0
	modify(array)                   // 传递给一个函数，并试图在函数体内修改这个数组内容
	fmt.Println(&quot;In main(), array values:&quot;, array)
}
该程序的执行结果为：
In modify(), array values: [10 2 3 4 5 0 0 0 0 0]
In main(), array values: [1 2 3 4 5 0 0 0 0 0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以用指针的概念解决这个问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package main

import &quot;fmt&quot;

func modify(array *[10]int) { //接收指针值
	array[0] = 10 // 试图修改数组的第一个元素
	fmt.Println(&quot;In modify(), array values:&quot;, array)
}
func main() {
	array := [10]int{1, 2, 3, 4, 5} // 定义并初始化一个数组，未定义的元素为零值，即0
	modify(&amp;amp;array)                  // 传递指针
	fmt.Println(&quot;In main(), array values:&quot;, array)
}
该程序的执行结果为：
In modify(), array values: &amp;amp;[10 2 3 4 5 0 0 0 0 0]
In main(), array values: [10 2 3 4 5 0 0 0 0 0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你使用多维数组，有一些内容你必须录入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;a := [2][2]int{ [2]int{1,2}, [2]int{3,4} }
a := [2][2]int{ [...]int{1,2}, [...]int{3,4} }//Go 会自动统计元素的个数。
a := [2][2]int{ {1,2}, {3,4} }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;切片slice&quot;&gt;切片slice&lt;/h2&gt;

&lt;p&gt;slice 与array 接近，但是在新的元素加入的时候可以增加长度。slice 总是指向底层的一个array。slice 是一个指向array 的指针，这是其与array 不同的地方；slice 是引用类型，这意味着当赋值某个slice 到另外一个变量，两个引用会指向同一个array。例如，如果一个函数需要一个slice 参数，在其内对slice 元素的修改也会体现在函数调用者中，这和传递底层的array 指针类似。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建数组切片&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;创建数组切片的方法主要有两种——基于数组和直接创建。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基于数组：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;func main() {
	// 先定义一个数组
	var myArray [10]int = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	// 基于数组创建一个数组切片
	var mySlice []int = myArray[:5]
	fmt.Println(&quot;Elements of myArray: &quot;)
	for _, v := range myArray {
		fmt.Print(v, &quot; &quot;)
	}
	fmt.Println(&quot;\nElements of mySlice: &quot;)
	for _, v := range mySlice {
		fmt.Print(v, &quot; &quot;)
	}
	fmt.Println()
}
运行结果为：
Elements of myArray:
1 2 3 4 5 6 7 8 9 10
Elements of mySlice:
1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go语言支持用myArray[first:last]这样的方式来基于数组生成一个数组切片&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;基于myArray的所有元素创建数组切片：
mySlice = myArray[:]
基于myArray的前5个元素创建数组切片：
mySlice = myArray[:5]
基于从第5个元素开始的所有元素创建数组切片：
mySlice = myArray[5:]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;直接创建：&lt;/strong&gt;&lt;br /&gt;
并非一定要事先准备一个数组才能创建数组切片。Go语言提供的内置函数make()可以用于灵活地创建数组切片。当然，事实上还会有一个匿名数组被创建出来，只是不需要我们来操心而已。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;创建一个初始元素个数为5的数组切片，元素初始值为0：
mySlice1 := make([]int, 5)
创建一个初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间：
mySlice2 := make([]int, 5, 10)
直接创建并初始化包含5个元素的数组切片：
mySlice3 := []int{1, 2, 3, 4, 5}
直接创建并初始化包含4个元素的数组切片：
mySlice3 := []interface{}{3,&quot;str&quot;, []int{3,4},func() {fmt.Println()}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;len-和-cap函数&quot;&gt;len() 和 cap()函数&lt;/h3&gt;

&lt;p&gt;因为切片(Slice)是数组上的抽象。它实际上使用数组作为底层结构体.len()函数返回切片中存在的元素数量，其中cap()函数返回切片(Slice)的容量(大小)，即可容纳多少个元素。以下是解释切片(Slice)的用法的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package main
import &quot;fmt&quot;
func main() {
   var numbers = make([]int,3,5)
   printSlice(numbers)
}
func printSlice(x []int){
   fmt.Printf(&quot;len=%d cap=%d slice=%v\n&quot;,len(x),cap(x),x)
}
当上述代码编译和执行时，它产生以下结果：
len=3 cap=5 slice=[0 0 0]

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;append和copy函数&quot;&gt;&lt;strong&gt;append()和copy()函数&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;切片(Slice)允许使用append()函数增加切片的容量(大小)。使用copy()函数，将源切片的内容复制到目标切片。以下是示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;package main

import &quot;fmt&quot;

func main() {
   var numbers []int
   printSlice(numbers)

   /* append allows nil slice */
   numbers = append(numbers, 0)
   printSlice(numbers)

   /* add one element to slice*/
   numbers = append(numbers, 1)
   printSlice(numbers)

   /* add more than one element at a time*/
   numbers = append(numbers, 2,3,4)
   printSlice(numbers)

   /* create a slice numbers1 with double the capacity of earlier slice*/
   numbers1 := make([]int, len(numbers), (cap(numbers))*2)

   /* copy content of numbers to numbers1 */
   copy(numbers1,numbers)
   printSlice(numbers1)   
}

func printSlice(x []int){
   fmt.Printf(&quot;len=%d cap=%d slice=%v\n&quot;,len(x),cap(x),x)
}
Go
当上述代码编译和执行时，它产生以下结果：

len=0 cap=0 slice=[]
len=1 cap=2 slice=[0]
len=2 cap=2 slice=[0 1]
len=5 cap=8 slice=[0 1 2 3 4]
len=5 cap=16 slice=[0 1 2 3 4]

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;字典map&quot;&gt;字典map&lt;/h2&gt;

&lt;p&gt;map 可以认为是一个用字符串做索引的数组（在其最简单的形式下）。下面定义了map 类型，用于将string（月的缩写）转换为int – 那个月的天数。一般定义map 的方法是：map[&lt;from type=&quot;&quot;&gt;]&lt;to type=&quot;&quot;&gt;&lt;/to&gt;&lt;/from&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;	monthdays := map[string]int{
		&quot;Jan&quot;: 31, &quot;Feb&quot;: 28, &quot;Mar&quot;: 31,
		&quot;Apr&quot;: 30, &quot;May&quot;: 31, &quot;Jun&quot;: 30,
		&quot;Jul&quot;: 31, &quot;Aug&quot;: 31, &quot;Sep&quot;: 30,
		&quot;Oct&quot;: 31, &quot;Nov&quot;: 30, &quot;Dec&quot;: 31, //逗号是必须的
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;留意，当只需要声明一个map 的时候，使用make 的形式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;monthdays := make(map[string]int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当在map 中索引（搜索）时，使用方括号。例如打印出12 月的天数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;fmt.Printf(&quot;%d\n&quot;,monthdays[&quot;Dec&quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当对array、slice、string 或者map 循环遍历的时候，range 会帮助你，每次调用，它都会返回一个键和对应的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;year := 0
for _, days := range monthdays { //键没有使用，因此用_, days
	year += days
}
fmt.Printf(&quot;Numbers of days in a year:%d\n&quot;, year)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;向map 增加元素，可以这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;monthdays[&quot;Undecim&quot;] = 30   //添加一个月
monthdays[&quot;Feb&quot;] = 29   //年时重写这个元素
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;检查元素是否存在，可以使用下面的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;var value int
var present bool
value, present =monthdays[&quot;Jan&quot;]   //如果存在，present 则有值true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者更接近Go 的方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;v, ok := monthdays[&quot;Jan&quot;]   //“逗号ok”形式
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以从map 中移除元素：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;delete(monthdays, &quot;Mar&quot;)   //删除&quot;Mar&quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常来说语句delete(m, x) 会删除map 中由m[x] 建立的实例。&lt;/p&gt;
</description>
        <pubDate>Sun, 25 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/</guid>
        
        
      </item>
    
      <item>
        <title>Go语言学习笔记（二） 基本语法、变量、常量、类型 (1)</title>
        <description>&lt;h2 id=&quot;基本语法&quot;&gt;基本语法&lt;/h2&gt;

&lt;h2 id=&quot;go语言中的标记&quot;&gt;Go语言中的标记&lt;/h2&gt;

&lt;p&gt;Go程序是由各种标记组成的，标记可以是关键字，标识符，常量，字符串文字或符号。例如，以下Go语句由六个标记组成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;fmt.Println(&quot;Hello, World!&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个标记单独表示为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;fmt
.
Println
(
&quot;Hello, World!&quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;行分隔符&quot;&gt;行分隔符&lt;/h2&gt;

&lt;p&gt;在Go程序中，行分隔符键是语句终止符。 也就是说，每个单独的语句不需要特殊的分隔符如：&lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt; ，也不需要像在C编译器放置&lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt; 作为语句终止符以指示一个逻辑实体的结束。&lt;/p&gt;

&lt;p&gt;例如，以下是两个不同的语句：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Go&quot;&gt;fmt.Println(&quot;Hello, World!&quot;)
fmt.Println(&quot;I am in Go Programming World!&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;注释&quot;&gt;注释&lt;/h3&gt;

&lt;p&gt;注释就类似在Go程序中帮助文本，并且它们被编译器忽略。 它们以&lt;code class=&quot;highlighter-rouge&quot;&gt;/*&lt;/code&gt;开始，并以字符&lt;code class=&quot;highlighter-rouge&quot;&gt;*/&lt;/code&gt;结尾，如下所示：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;/* my first program comments in Go */&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不能在注释中包含注释，并且不能在字符串或字符文字中出现。&lt;/p&gt;

&lt;h2 id=&quot;标识符&quot;&gt;标识符&lt;/h2&gt;

&lt;p&gt;Go标识符是用于标识变量，函数或任何其他用户定义项目的名称。标识符以字母&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt;或下划线&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;开头，后跟零个或多个字母，下划线和数字(&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt;)组成。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;标识符 = 字母 {字母&lt;/td&gt;
      &lt;td&gt;unicode数字}。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Go不允许在标识符中使用标点符号，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;。 Go是一种区分大小写的编程语言。 因此，&lt;code class=&quot;highlighter-rouge&quot;&gt;Manpower&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;manpower&lt;/code&gt;在Go中是两个不同的标识符。以下是一些可接受(合法)的标识符示例：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;mahesh&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kumar&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;abc&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move_name&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a_123&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myname50&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_temp&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a23b9&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retVal&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;关键词&quot;&gt;关键词&lt;/h2&gt;

&lt;p&gt;以下列表显示Go中的保留字。这些保留字不能用作常量或变量或任何其他标识符名称。&lt;/p&gt;

&lt;p&gt;break&lt;/p&gt;

&lt;p&gt;default&lt;/p&gt;

&lt;p&gt;func&lt;/p&gt;

&lt;p&gt;interface&lt;/p&gt;

&lt;p&gt;select&lt;/p&gt;

&lt;p&gt;case&lt;/p&gt;

&lt;p&gt;defer&lt;/p&gt;

&lt;p&gt;go&lt;/p&gt;

&lt;p&gt;map&lt;/p&gt;

&lt;p&gt;struct&lt;/p&gt;

&lt;p&gt;chan&lt;/p&gt;

&lt;p&gt;else&lt;/p&gt;

&lt;p&gt;goto&lt;/p&gt;

&lt;p&gt;package&lt;/p&gt;

&lt;p&gt;switch&lt;/p&gt;

&lt;p&gt;const&lt;/p&gt;

&lt;p&gt;fallthrough&lt;/p&gt;

&lt;p&gt;if&lt;/p&gt;

&lt;p&gt;range&lt;/p&gt;

&lt;p&gt;type&lt;/p&gt;

&lt;p&gt;continue&lt;/p&gt;

&lt;p&gt;for&lt;/p&gt;

&lt;p&gt;import&lt;/p&gt;

&lt;p&gt;return&lt;/p&gt;

&lt;p&gt;var&lt;/p&gt;

&lt;h2 id=&quot;go语言的空白行&quot;&gt;Go语言的空白行&lt;/h2&gt;

&lt;p&gt;只包含空格的行，或者可能带有注释，被称为空行，Go编译器完全忽略它。&lt;/p&gt;

&lt;p&gt;空白行是用于描述空格，制表符，换行符和注释的术语。 空格将语句的一部分与另一个语句隔开，并使编译器能够识别语句中的一个元素(例如&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;)结束和下一个元素开始的位置。因此，在下面的语句中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var age int;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;age&lt;/code&gt;之间必须至少有一个空格字符(通常是一个空格)，以便编译器能够区分它们。 另一方面，如以下语句中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fruit = apples + oranges;   // get the total fruit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;fruit&lt;/code&gt; 和&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;之间，或在&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;apples&lt;/code&gt;之间可不需要空格字符，但是如果想要增加可读性，那么可以随意添加。&lt;/p&gt;

&lt;h2 id=&quot;变量&quot;&gt;变量&lt;/h2&gt;

&lt;p&gt;Go语言的变量声明方式与C和C++语言有明显的不同。对于纯粹的变量声明，Go语言引入了关键字var，而类型信息放在变量名之后，示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;var v1 int
var v2 string
var v3 [10]int // 数组
var v4 []int // 数组切片
var v5 struct {
f int
}
var v6 *int // 指针
var v7 map[string]int // map，key为string类型，value为int类型
var v8 func(a int) int
var (
v1 int
v2 string
)
var v1 int = 10 // 正确的使用方式1
var v2 = 10 // 正确的使用方式2，编译器可以自动推导出v2的类型
v3 := 10 // 正确的使用方式3，编译器可以自动推导出v3的类型

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定类型已不再是必需的，Go编译器可以从初始化表达式的右值推导出该变量应该声明为哪种类型，这让Go语言看起来有点像动态类型语言，尽管&lt;strong&gt;Go语言实际上是不折不扣的强类型语言（静态类型语言）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误，比如下面这个写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;var i int
i := 2
会导致类似如下的编译错误：
no new variables on left side of :=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;多重赋值功能&lt;/strong&gt;，比如下面这个交换i和j变量的语句：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;i, j = j, i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多重返回和匿名变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;func GetName() (firstName, lastName, nickName string) {
return &quot;May&quot;, &quot;Chan&quot;, &quot;Chibi Maruko&quot;
}
若只想获得nickName，则函数调用语句可以用如下方式编写：
_, _, nickName := GetName()

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;常量&quot;&gt;常量&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Go语言的字面常量更接近我们自然语言中的常量概念，它是无类型的。&lt;/strong&gt;只要这个常量在相应类型的值域范围内，就可以作为该类型的常量，比如上面的常量-12，它可以赋值给int、uint、int32、int64、float32、float64、complex64、complex128等类型的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;-12
3.14159265358979323846 // 浮点类型的常量
3.2+12i // 复数类型的常量
true // 布尔类型的常量
&quot;foo&quot; // 字符串常量
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过const关键字，你可以给字面常量指定一个友好的名字：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;const Pi float64 = 3.14159265358979323846
const zero = 0.0 // 无类型浮点常量
const (
size int64 = 1024
eof = -1 // 无类型整型常量
)
const u, v float32 = 0, 3 // u = 0.0, v = 3.0，常量的多重赋值
const a, b, c = 3, 4, &quot;foo&quot;
// a = 3, b = 4, c = &quot;foo&quot;, 无类型整型和字符串常量
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;常量定义的右值也可以是一个在编译期运算的常量表达式&lt;/strong&gt;，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;const mask = 1 &amp;lt;&amp;lt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;由于常量的赋值是一个编译期行为，所以右值不能出现任何需要运行期才能得出结果的表达式&lt;/strong&gt;，比如试图以如下方式定义常量就会导致编译错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;const Home = os.GetEnv(&quot;HOME&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因很简单，os.GetEnv()只有在运行期才能知道返回结果，在编译期并不能确定，所以无法作为常量定义的右值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Go语言预定义了这些常量：true、false和iota。&lt;/strong&gt;iota比较特殊，可以被认为是一个可被编译器修改的常量，在每一个const关键字出现时被重置为0，然后在下一个const出现之前，每出现一次iota，其所代表的数字会自动增1。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;const ( // iota被重设为0
c0 = iota // c0 == 0
c1 = iota // c1 == 1
c2 = iota // c2 == 2
)
const (
a = 1 &amp;lt;&amp;lt; iota // a == 1 (iota在每个const开头被重设为0)
b = 1 &amp;lt;&amp;lt; iota // b == 2
c = 1 &amp;lt;&amp;lt; iota // c == 4
)
const (
u = iota * 42 // u == 0
v float64 = iota * 42 // v == 42.0
w = iota * 42 // w == 84
)
const x = iota // x == 0 (因为iota又被重设为0了)
const y = iota // y == 0 (同上)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;const ( // iota被重设为0
c0 = iota // c0 == 0
c1 // c1 == 1
c2 // c2 == 2
)
const (
a = 1 &amp;lt;&amp;lt;iota // a == 1 (iota在每个const开头被重设为0)
b // b == 2
c // c == 4
)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go语言并不支持众多其他语言明确支持的enum关键字。伪枚举：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;const (
Sunday = iota
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
numberOfDays // 这个常量没有导出
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;类型&quot;&gt;类型&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Go语言内置以下这些基础类型：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;布尔类型：&lt;/strong&gt;bool。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;整型：&lt;/strong&gt;int8、byte、int16、int、uint、uintptr等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;浮点类型：&lt;/strong&gt;float32、float64。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;复数类型：&lt;/strong&gt;complex64、complex128。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;字符串：&lt;/strong&gt;string。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;字符类型：&lt;/strong&gt;rune。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;错误类型：&lt;/strong&gt;error。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，Go语言也支持以下这些&lt;strong&gt;复合类型：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;指针（pointer）&lt;/li&gt;
  &lt;li&gt;数组（array）&lt;/li&gt;
  &lt;li&gt;切片（slice）&lt;/li&gt;
  &lt;li&gt;字典（map）&lt;/li&gt;
  &lt;li&gt;通道（chan）&lt;/li&gt;
  &lt;li&gt;结构体（struct）&lt;/li&gt;
  &lt;li&gt;接口（interface）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;int和int32在Go语言里被认为是两种不同的类型，编译器也不会帮你自动做类型转换：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;var value2 int32
value1 := 64 // value1将会被自动推导为int类型
value2 = value1 // 编译错误
编译错误类似于：
cannot use value1 (type int) as type int32 in assignment。
使用强制类型转换可以解决这个编译错误：
value2 = int32(value1) // 编译通过
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两个不同类型的整型数不能直接比较，比如int8类型的数和int类型的数不能直接比较，但各种类型的整型变量都可以直接与字面常量（literal）进行比较，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;var i int32
var j int64
i, j = 1, 2
if i == j { // 编译错误
fmt.Println(&quot;i and j are equal.&quot;)
}
if i == 1 || j == 2 { // 编译通过
fmt.Println(&quot;i and j are equal.&quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Go语言中，字符串也是一种基本类型。相比之下， C/C++语言中并不存在原生的字符串类型，通常使用字符数组来表示，并以字符指针来传递。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;var str string // 声明一个字符串变量
str = &quot;Hello world&quot; // 字符串赋值
ch := str[0] // 取字符串的第一个字符
fmt.Printf(&quot;The length of \&quot;%s\&quot; is %d \n&quot;, str, len(str))
fmt.Printf(&quot;The first character of \&quot;%s\&quot; is %c.\n&quot;, str, ch)
输出结果为：
The length of &quot;Hello world&quot; is 11
The first character of &quot;Hello world&quot; is H.
str := &quot;Hello world&quot; // 字符串也支持声明时进行初始化的做法
str[0] = 'X' // 编译错误
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 19 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-%E5%8F%98%E9%87%8F-%E5%B8%B8%E9%87%8F-%E7%B1%BB%E5%9E%8B-(1)/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-%E5%8F%98%E9%87%8F-%E5%B8%B8%E9%87%8F-%E7%B1%BB%E5%9E%8B-(1)/</guid>
        
        
      </item>
    
      <item>
        <title>Go语言学习笔记（一） 简介、安装</title>
        <description>&lt;h2 id=&quot;为什么选择go&quot;&gt;为什么选择Go&lt;/h2&gt;

&lt;p&gt;编程语言已经非常多，偏性能敏感的编译型语言有 C、C++、Java、C#、Delphi和Objective-C等，偏快速业务开发的动态解析型语言有PHP、Python、Perl、Ruby、JavaScript和Lua等，面向特定领域的语言有Erlang、R和MATLAB等，那么我们为什么需要 Go这样一门新语言呢？&lt;/p&gt;

&lt;p&gt;Go语言官方自称，之所以开发Go 语言，是因为“近10年来开发程序之难让我们有点沮丧”。这一定位暗示了Go语言希望取代C和Java的地位，成为最流行的通用开发语言。&lt;/p&gt;

&lt;p&gt;Go希望成为互联网时代的C语言。多数系统级语言（包括Java和C#）的根本编程哲学来源于C++，将C++的面向对象进一步发扬光大。但是Go语言的设计者却有不同的看法，他们认为C++ 真的没啥好学的，值得学习的是C语言。&lt;strong&gt;C语言经久不衰的根源是它足够简单。因此，Go语言也要足够简单！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;单机时代的语言可以只关心问题本身的解决，但是随着工程规模的不断扩大，软件复杂度的不断增加，软件工程也成为语言设计层面要考虑的重要课题。多数软件需要一个团队共同去完成，在团队协作的过程中，人们需要建立统一的交互语言来降低沟通的成本。规范化体现在多个层面，如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;代码风格规范&lt;/li&gt;
  &lt;li&gt;错误处理规范&lt;/li&gt;
  &lt;li&gt;包管理&lt;/li&gt;
  &lt;li&gt;契约规范（接口）&lt;/li&gt;
  &lt;li&gt;单元测试规范&lt;/li&gt;
  &lt;li&gt;功能开发的流程规范&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Go语言很可能是第一个将代码风格强制统一的语言&lt;/strong&gt;，例如Go语言要求public的变量必须以大写字母开头，private变量则以小写字母开头，这种做法不仅免除了public、private关键字，更重要的是统一了命名风格。&lt;/p&gt;

&lt;p&gt;计算机软件经历了数十年的发展，形成了多种学术流派，有面向过程编程、面向对象编程、函数式编程、面向消息编程等，这些思想究竟孰优孰劣，众说纷纭。&lt;/p&gt;

&lt;p&gt;C语言是纯过程式的，这和它产生的历史背景有关。Java语言则是激进的面向对象主义推崇者，典型表现是它不能容忍体系里存在孤立的函数。而Go语言没有去否认任何一方，而是用批判吸收的眼光，将所有编程思想做了一次梳理，融合众家之长，但时刻警惕特性复杂化，极力维持语言特性的简洁，力求小而精。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从编程范式的角度来说，Go语言是变革派，而不是改良派。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;语言简史&quot;&gt;语言简史&lt;/h2&gt;

&lt;p&gt;提起Go语言的出身，我们就必须将我们饱含敬意的眼光投向持续推出惊世骇俗成果的贝尔实验室。贝尔实验室已经走出了多位诺贝尔奖获得者，一些对于现在科技至关重要的研究成果，比如晶体管、通信技术、数码相机的感光元件CCD和光电池等都源自贝尔实验室。该实验室在科技界的地位可想而之，是一个毫无争议的科研圣地。&lt;/p&gt;

&lt;p&gt;这里我们重点介绍一下贝尔实验室中一个叫计算科学研究中心的部门对于操作系统和编程语言的贡献。回溯至1969年，肯·汤普逊（Ken Thompson）和丹尼斯·里奇（Dennis Ritchie）在贝尔实验室的计算科学研究中心里开发出了Unix这个大名鼎鼎的操作系统，还因为开发Unix而衍生出了一门同样赫赫有名的编程语言——C语言。对于很大一部分人而言，Unix就是操作系统的鼻祖，C语言也是计算机课程中最广泛使用的编程语言。Unix和C语言在过去的几十年以来已经造就了无数的成功商业故事，比如曾在90年代如日中天的太阳微系统（Sun MicroSystems），现在正如日中天的苹果的Mac OS X操作系统其实也可以认为是Unix的一个变种（FreeBSD）。在之后的几十年中，该研究项目又演变出了另一个叫Inferno的项目分支，以及一个名为Limbo的编程语言。Limbo是用于开发运行在小型计算机上的分布式应用的编程语言，它支持模块化编程，编译期和运行时的强类型检查，进程内基于具有类型的通信通道，原子性垃圾收集和简单的抽象数据类型。它被设计为：即便是在没有硬件内存保护的小型设备上，也能安全运行。&lt;/p&gt;

&lt;p&gt;Limbo语言被认为是Go语言的前身，不仅仅因为是同一批人设计的语言，而是Go语言确实从Limbo语言中继承了众多优秀的特性。贝尔实验室后来经历了多次的动荡，包括肯·汤普逊在内的Plan 9项目原班人马加入了Google。在Google，他们创造了Go语言。早在2007年9月，Go语言还是这帮大牛的20%自由时间的实验项目。到了2008年5月，Google发现了Go语言的巨大潜力，从而开始全力支持这个项目，让这批人可以全身心投入Go语言的设计和开发工作中。&lt;strong&gt;Go语言的第一个版本在2009年11月正式对外发布，并在此后的两年内快速迭代，发展迅猛。第一个正式版本的Go语言于2012年3月28日正式发布，让Go语言迎来了第一个引人瞩目的里程碑。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基于Google对开源的一贯拥抱态度，&lt;strong&gt;Go语言也自然而然地选择了开源方式发布&lt;/strong&gt;，并使用BSD授权协议。任何人可以查看Go语言的所有源代码，并可以为Go语言发展而奉献自己的力量。&lt;/p&gt;

&lt;h2 id=&quot;语言特性&quot;&gt;语言特性&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;自动垃圾回收：&lt;/strong&gt;到目前为止，内存泄露的最佳解决方案是在语言级别引入自动垃圾回收算法（GarbageCollection，简称GC）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;更丰富的内置类型：&lt;/strong&gt;Go语言内置了一个对于其他静态类型语言通常用库方式支持的字典类型（map）。新增的数据类型：数组切片（Slice）。我们可以认为数组切片是一种可动态增长而且不限制数据类型的数组。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;函数多返回值：&lt;/strong&gt;Go语言革命性地在静态开发语言阵营中率先提供了多返回值功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;错误处理：&lt;/strong&gt;Go语言引入了3个关键字用于标准的错误处理流程，这3个关键字分别为defer、panic和recover。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;匿名函数和闭包：&lt;/strong&gt;在Go语言中，所有的函数也是值类型，可以作为参数传递。Go语言支持常规的匿名函数和闭包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类型和接口：&lt;/strong&gt;Go语言并没有直接沿袭C++和Java的传统去设计一个超级复杂的类型系统，不支持继承和重载，而只是支持了最基本的类型组合功能。它还引入了一个无比强大的“非侵入式”接口的概念，即类型和接口不紧密绑定。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;并发编程：&lt;/strong&gt;Go语言引入了goroutine概念，是一种比线程更加轻盈、更省资源的协程。通过使用goroutine而不是裸用操作系统的并发机制，以及使用消息传递来共享内存而不是使用共享内存来通信，Go语言让并发编程变得更加轻盈和安全。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;反射：&lt;/strong&gt;Go语言的反射实现了反射的大部分功能，但没有像Java语言那样内置类型工厂，故而无法做到像Java那样通过类型字符串创建对象实例。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;语言交互性：&lt;/strong&gt;由于Go语言与C语言之间的天生联系，可以按Cgo的特定语法混合编写C语言代码，然后Cgo工具可以将这些混合的C代码提取并生成对于C功能的调用包装代码。开发者基本上可以完全忽略这个Go语言和C语言的边界是如何跨越的。&lt;/p&gt;

&lt;h2 id=&quot;安装go&quot;&gt;安装Go&lt;/h2&gt;

&lt;p&gt;下载地址：&lt;a href=&quot;https://golang.org/dl/&quot;&gt;Go下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一键安装就好，而且环境变量都给配置好了。&lt;/p&gt;

&lt;p&gt;IDE的选择，作为一个JetBrains的粉丝，自从用过idea之后就再也回不去eclipse了，自然要使用JetBrainsGoLand。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jetbrains.com/go/download/#section=windows&quot;&gt;IDE下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/aomi/p/8288137.html&quot;&gt;激活码&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 15 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80-%E7%AE%80%E4%BB%8B-%E5%AE%89%E8%A3%85/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80-%E7%AE%80%E4%BB%8B-%E5%AE%89%E8%A3%85/</guid>
        
        
      </item>
    
  </channel>
</rss>
